---
typora-root-url: ..
---

# LeetCode第62号问题：不同路径

### 题目描述

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

**示例 1：**

![62](/image/62.png)

```
输入：m = 3, n = 7
输出：28
```

### 题目解析

由图可以看出，每个位置可以从上面和左边到达，即(i,j) 可以从(i-1,j) 和(i,j-1)到达，所以(i,j)处的路径条数等于上面位置的路径条数+左边位置的路径条数。因此很容易从子状态转移到当前状态，进而可以找到状态转移方程。

### 代码描述

```java
class Solution {
    public int uniquePaths(int m, int n) {
        //dp[i][j]表示从（0,0）走到（i,j）的路径条数
        //dp[i][j] = dp[i -1][j] + dp[i][j - 1];
        int[][] dp = new int[m][n];
        for(int i = 0; i < m; ++i){
            for(int j = 0; j < n; ++j){
                if(i == 0){
                    dp[0][j] = 1;
                }else if(j == 0){
                    dp[i][0] = 1;
                }else{
                    dp[i][j] = dp[i -1][j] + dp[i][j - 1];
                }
            }
        }
        return dp[m-1][n-1];
    }
}
```

### 复杂度分析

- 时间复杂度：O(mn)
- 空间复杂度：O(mn)，即存储所有状态所需要的空间，dp数组的大小。因为当前位置只与上面那个和下面那个的值有关，所以可以用滚动数组来优化空间复杂度，得到为O(n)