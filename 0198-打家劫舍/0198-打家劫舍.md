# LeetCode第198号问题：打家劫舍

难度：mid

### 题目描述

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

**示例 1：**

```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

### 题目解析

定义dp[i]的含义，dp[i]表示前i间房子偷到的一共的最大金额。

dp[i] = Math.max(dp[i-1] , (dp[i-2] + nums[i]));

考虑边界情况
dp[0]=nums[0]     						  只有一间房屋，则偷窃该房屋
dp[1]=max(nums[0],nums[1])     只有两间房屋，选择其中金额较高的房屋进行偷窃




### 代码描述

```java
class Solution {
    public int rob(int[] nums) {
        //dp[i]表示第i位置能偷到的一共的最大金额
        //i偷，则dp[i] = nums[i] + dp[i-2]
        //i不偷，则dp[i] = dp[i-1]
        int n = nums.length;
        if(n == 0 ){
            return 0;
        }
        if(n == 1){
            return nums[0];
        }
        int[] dp = new int[n];
        dp[0] = nums[0];
        //dp[1] = nums[1];
        for(int i = 1; i < n; ++i){
            if(i == 1){
                dp[i] = nums[i] > nums[i - 1] ? nums[i] : nums[i - 1];
            }else{
                 dp[i] = Math.max(dp[i-1],(dp[i-2] + nums[i]));
            }
        }
        return dp[n - 1];
    }
}
```



打家劫舍和最长上升子序列定义的状态不一样。因为以i结尾可以直接确定这个递增序列，即题目的答案，而打家劫舍中以i结尾，只能说明偷这个房间，并不能确定后面的偷哪个房子，进而确定总金额，而是就拿[2,1]来说，如果打家劫舍定义的也是以nums[i]结尾，那么就必须要偷i位置的房子，不能偷i-1位置的。但是此时可能i-1处的金额更大，偷i-1才能得到更大的总金额，所以只能定义为前i间房子偷到的一共的最大金额。